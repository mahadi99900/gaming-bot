# -*- coding: utf-8 -*-
import os
import json
import random
import time
import uuid
import logging
import asyncio

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup
from telegram.constants import ParseMode
from telegram.ext import (
    Application,
    CommandHandler,
    ContextTypes,
    CallbackQueryHandler,
    MessageHandler,
    filters,
)

# --- рж▓ржЧрж┐ржВ рж╕рзЗржЯржЖржк ---
logging.basicConfig(format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO)
logger = logging.getLogger(__name__)

# --- ржХржиржлрж┐ржЧрж╛рж░рзЗрж╢ржи ржПржмржВ ржХржирж╕рзНржЯрзНржпрж╛ржирзНржЯ ---
TELEGRAM_TOKEN = '7716441936:AAFIoRkzS51fw2dgTs8MCVBmY-lK-OyYGO0' # ржЖржкржирж╛рж░ ржЖрж╕рж▓ ржЯрзЛржХрзЗржи
OWNER_ID = 6776334925
CREATOR_LINK = 'https://t.me/mahadihasan099'
CHANNEL_LINK = 'https://t.me/battle_nexus'
FOOTER = f"\n\n- - - - - - - - - - - - - - -\n- с┤Д╩Ас┤Зс┤Ас┤Ыс┤Зс┤Е ╩Щ╩П: {CREATOR_LINK}\n- с┤Д╩Ьс┤А╔┤╔┤с┤З╩Я: {CHANNEL_LINK}"

DATA_FILE = 'bot_data.json'
PENDING_BETS = {}
PENDING_BATTLES = {}

data_lock = asyncio.Lock()

# --- ржЧрзЗржорзЗрж░ ржнрзНржпрж╛рж░рж┐рзЯрзЗржмрж▓ ---
ANIMALS = [
    {'name': 'Cat', 'icon': 'ЁЯРИ', 'base_power': 10}, {'name': 'Dog', 'icon': 'ЁЯРХ', 'base_power': 12},
    {'name': 'Rabbit', 'icon': 'ЁЯРЗ', 'base_power': 8}, {'name': 'Deer', 'icon': 'ЁЯжМ', 'base_power': 20},
    {'name': 'Wolf', 'icon': 'ЁЯР║', 'base_power': 30}, {'name': 'Lion', 'icon': 'ЁЯжБ', 'base_power': 50},
    {'name': 'Tiger', 'icon': 'ЁЯРЕ', 'base_power': 55}, {'name': 'Dragon', 'icon': 'ЁЯРЙ', 'base_power': 100},
]
ANIMAL_QUALITIES = {'F': 0.5, 'D': 0.8, 'C': 1.0, 'B': 1.2, 'A': 1.5, 'S': 2.0}

HUNT_COOLDOWN, PRAY_COOLDOWN, CLAIM_COOLDOWN = 15, 60, 300
CLAIM_AMOUNT = 1000
PLAYER_XP_FOR_WIN, PLAYER_XP_FOR_LOSS = 50, 10

# --- ржмрж╣рзБржнрж╛рж╖рж┐ржХ ржЧрж╛ржЗржб ржЯрзЗржХрзНрж╕ржЯ ---
GUIDE_TEXTS = {
    'bn': (
        "ЁЯУЬ <b>ржмрзНржпрж╛ржЯрзЗрж▓ ржирзЗржХрзНрж╕рж╛рж╕ ржЧрзЗржо ржЧрж╛ржЗржб</b> ЁЯУЬ\n\n"
        "ржмрзНржпрж╛ржЯрзЗрж▓ ржирзЗржХрзНрж╕рж╛рж╕рзЗ рж╕рзНржмрж╛ржЧрждржо! ржПржЦрж╛ржирзЗ ржЖржкржирж┐ ржкрзНрж░рж╛ржгрзА рж╢рж┐ржХрж╛рж░ ржХрж░рждрзЗ, ржпрзБржжрзНржз ржХрж░рждрзЗ ржПржмржВ ржмржирзНржзрзБржжрзЗрж░ рж╕рж╛ржерзЗ ржмрж╛ржЬрж┐ ржзрж░рждрзЗ ржкрж╛рж░ржмрзЗржиред\n\n"
        "--- <b>ржмрзЗрж╕рж┐ржХ ржмрж╛ржЯржи</b> ---\n"
        "ЁЯПЮя╕П <b>Hunt:</b> ржирждрзБржи ржкрзНрж░рж╛ржгрзА рж╢рж┐ржХрж╛рж░ ржХрж░рзБржиред\n"
        "ЁЯР╛ <b>My Zoo:</b> ржЖржкржирж╛рж░ рж╕ржВржЧрзНрж░рж╣рзЗ ржерж╛ржХрж╛ рж╕ржХрж▓ ржкрзНрж░рж╛ржгрзА ржУ рждрж╛ржжрзЗрж░ ржорзЛржЯ рж╢ржХрзНрждрж┐ ржжрзЗржЦрзБржиред\n"
        "ЁЯСд <b>Profile:</b> ржЖржкржирж╛рж░ рж▓рзЗржнрзЗрж▓, ржЯрж╛ржХрж╛, ржПржХрзНрж╕ржкрж┐ ржЗрждрзНржпрж╛ржжрж┐ ржжрзЗржЦрзБржиред\n"
        "ЁЯЩП <b>Pray:</b> ржЖржкржирж╛рж░ ржнрж╛ржЧрзНржп ржмрзГржжрзНржзрж┐ ржХрж░рзБржиред\n"
        "ЁЯОБ <b>Claim:</b> ржкрзНрж░рждрж┐ рзл ржорж┐ржирж┐ржЯ ржкрж░ ржкрж░ ржмрж┐ржирж╛ржорзВрж▓рзНржпрзЗ ржХрзЯрзЗржи ржирж┐ржиред\n"
        "ЁЯПЖ <b>Leaderboard:</b> рж╕ржмржЪрзЗрзЯрзЗ ржзржирзА ржЦрзЗрж▓рзЛрзЯрж╛рзЬржжрзЗрж░ рждрж╛рж▓рж┐ржХрж╛ ржжрзЗржЦрзБржиред\n\n"
        "--- <b>ржЧрзНрж░рзБржк ржХржорж╛ржирзНржб</b> ---\n"
        "<code>/give @username [amount]</code> - ржЯрж╛ржХрж╛ ржкрж╛ржарж╛рждрзЗред\n"
        "<code>/sell [ID]</code> - ржкрзНрж░рж╛ржгрзА ржмрж┐ржХрзНрж░рж┐ ржХрж░рждрзЗред\n"
        "<code>/battle @username</code> - ржЕржирзНржпрзЗрж░ рж╕рж╛ржерзЗ ржпрзБржжрзНржз ржХрж░рждрзЗред\n"
        "<code>/slots [amount]</code> - ржмржЯрзЗрж░ рж╕рж╛ржерзЗ рж╕рзНрж▓ржЯ ржорзЗрж╢рж┐ржи ржЦрзЗрж▓рждрзЗред\n"
        "<code>/bet @username [amount]</code> - ржЕржирзНржпрзЗрж░ рж╕рж╛ржерзЗ ржЯрж╕ ржмрж╛ржЬрж┐ ржзрж░рждрзЗред\n\n"
        "тЪая╕П <b>ржЬрж░рзБрж░рж┐ ржирзЛржЯ:</b> ржЧрзНрж░рзБржкрзЗ ржмржирзНржзрзБржжрзЗрж░ рж╕рж╛ржерзЗ ржЦрзЗрж▓рждрзЗ рж╣рж▓рзЗ, рждрж╛ржжрзЗрж░ ржЕржмрж╢рзНржпржЗ ржмржЯржЯрж┐ржХрзЗ ржПржХржмрж╛рж░ <code>/start</code> ржХрж░рждрзЗ рж╣ржмрзЗред"
    ),
    'en': (
        "ЁЯУЬ <b>Battle Nexus Game Guide</b> ЁЯУЬ\n\n"
        "Welcome to Battle Nexus! Here you can hunt animals, battle, and bet with friends.\n\n"
        "--- <b>Basic Buttons</b> ---\n"
        "ЁЯПЮя╕П <b>Hunt:</b> Hunt for new animals.\n"
        "ЁЯР╛ <b>My Zoo:</b> See your animal collection and total power.\n"
        "ЁЯСд <b>Profile:</b> Check your level, balance, XP, etc.\n"
        "ЁЯЩП <b>Pray:</b> Increase your luck for better hunts.\n"
        "ЁЯОБ <b>Claim:</b> Get a free coin bonus every 5 minutes.\n"
        "ЁЯПЖ <b>Leaderboard:</b> See the list of the richest players.\n\n"
        "--- <b>Group Commands</b> ---\n"
        "<code>/give @username [amount]</code> - To send money.\n"
        "<code>/sell [ID]</code> - To sell an animal.\n"
        "<code>/battle @username</code> - To battle another player.\n"
        "<code>/slots [amount]</code> - To play slots with the bot.\n"
        "<code>/bet @username [amount]</code> - To coinflip with a player.\n\n"
        "тЪая╕П <b>Important Note:</b> To play with friends in a group, they must <code>/start</code> the bot at least once."
    ),
    'ar': (
        "ЁЯУЬ <b>╪п┘Д┘К┘Д ┘Д╪╣╪и╪й ╪и╪з╪к┘Д ┘Ж┘К┘Г╪│╪│</b> ЁЯУЬ\n\n"
        "╪г┘З┘Д╪з┘Л ╪и┘Г ┘Б┘К ╪и╪з╪к┘Д ┘Ж┘К┘Г╪│╪│! ┘З┘Ж╪з ┘К┘Е┘Г┘Ж┘Г ╪╡┘К╪п ╪з┘Д╪н┘К┘И╪з┘Ж╪з╪к ┘И╪з┘Д┘Е╪┤╪з╪▒┘Г╪й ┘Б┘К ╪з┘Д┘Е╪╣╪з╪▒┘Г ┘И╪з┘Д┘Е╪▒╪з┘З┘Ж╪й ┘Е╪╣ ╪з┘Д╪г╪╡╪п┘В╪з╪б.\n\n"
        "--- <b>╪з┘Д╪г╪▓╪▒╪з╪▒ ╪з┘Д╪г╪│╪з╪│┘К╪й</b> ---\n"
        "ЁЯПЮя╕П <b>╪╡┘К╪п:</b> ┘Д╪╡┘К╪п ╪н┘К┘И╪з┘Ж╪з╪к ╪м╪п┘К╪п╪й.\n"
        "ЁЯР╛ <b>╪н╪п┘К┘В╪к┘К:</b> ┘Д╪▒╪д┘К╪й ┘Е╪м┘Е┘И╪╣╪й ╪н┘К┘И╪з┘Ж╪з╪к┘Г ┘И┘В┘И╪к┘З╪з ╪з┘Д╪е╪м┘Е╪з┘Д┘К╪й.\n"
        "ЁЯСд <b>┘Е┘Д┘Б┘К ╪з┘Д╪┤╪о╪╡┘К:</b> ┘Д┘Д╪к╪н┘В┘В ┘Е┘Ж ┘Е╪│╪к┘И╪з┘Г╪М ╪▒╪╡┘К╪п┘Г╪М ┘Ж┘В╪з╪╖ ╪о╪и╪▒╪к┘Г╪М ╪е┘Д╪о.\n"
        "ЁЯЩП <b>╪п╪╣╪з╪б:</b> ┘Д╪▓┘К╪з╪п╪й ╪н╪╕┘Г ┘Б┘К ╪з┘Д╪╡┘К╪п.\n"
        "ЁЯОБ <b>┘Е┘Г╪з┘Б╪г╪й:</b> ┘Д┘Д╪н╪╡┘И┘Д ╪╣┘Д┘Й ╪╣┘Е┘Д╪з╪к ┘Е╪м╪з┘Ж┘К╪й ┘Г┘Д 5 ╪п┘В╪з╪ж┘В.\n"
        "ЁЯПЖ <b>╪з┘Д┘Е╪к╪╡╪п╪▒┘И┘Ж:</b> ┘Д╪▒╪д┘К╪й ┘В╪з╪ж┘Е╪й ╪г╪║┘Ж┘Й ╪з┘Д┘Д╪з╪╣╪и┘К┘Ж.\n\n"
        "--- <b>╪г┘И╪з┘Е╪▒ ╪з┘Д┘Е╪м┘Е┘И╪╣╪й</b> ---\n"
        "<code>/give @username [amount]</code> - ┘Д╪е╪▒╪│╪з┘Д ╪з┘Д╪г┘Е┘И╪з┘Д.\n"
        "<code>/sell [ID]</code> - ┘Д╪и┘К╪╣ ╪н┘К┘И╪з┘Ж.\n"
        "<code>/battle @username</code> - ┘Д┘Е╪н╪з╪▒╪и╪й ┘Д╪з╪╣╪и ╪в╪о╪▒.\n"
        "<code>/slots [amount]</code> - ┘Д┘Д╪╣╪и ┘Е╪з┘Г┘К┘Ж╪й ╪з┘Д┘В┘Е╪з╪▒ ┘Е╪╣ ╪з┘Д╪и┘И╪к.\n"
        "<code>/bet @username [amount]</code> - ┘Д┘Д┘Е╪▒╪з┘З┘Ж╪й ╪и┘В┘Д╪и ╪з┘Д╪╣┘Е┘Д╪й ┘Е╪╣ ┘Д╪з╪╣╪и.\n\n"
        "тЪая╕П <b>┘Е┘Д╪з╪н╪╕╪й ┘З╪з┘Е╪й:</b> ┘Д┘Д╪╣╪и ┘Е╪╣ ╪з┘Д╪г╪╡╪п┘В╪з╪б ┘Б┘К ┘Е╪м┘Е┘И╪╣╪й╪М ┘К╪м╪и ╪╣┘Д┘К┘З┘Е ╪г┘И┘Д╪з┘Л ╪и╪п╪б ╪з┘Д╪и┘И╪к ╪и╪з╪│╪к╪о╪п╪з┘Е ╪з┘Д╪г┘Е╪▒ <code>/start</code> ┘Е╪▒╪й ┘И╪з╪н╪п╪й ╪╣┘Д┘Й ╪з┘Д╪г┘В┘Д."
    )
}


# --- ржбрзЗржЯрж╛ ржорзНржпрж╛ржирзЗржЬржорзЗржирзНржЯ ржУ рж╣рзЗрж▓рзНржкрж╛рж░ ржлрж╛ржВрж╢ржи ---
def load_data():
    if not os.path.exists(DATA_FILE): return {}
    try:
        with open(DATA_FILE, 'r', encoding='utf-8') as f: return json.load(f)
    except json.JSONDecodeError: return {}

async def save_data(data):
    async with data_lock:
        with open(DATA_FILE, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=4, ensure_ascii=False)

def ensure_user_data(data, user_id, username):
    user_id_str = str(user_id)
    if user_id_str not in data:
        data[user_id_str] = {'username': username, 'balance': 100, 'xp': 0, 'luck': 1.0, 'zoo': [], 'last_hunt': 0, 'last_pray': 0, 'last_claim': 0}

def find_user_id_by_username(data, username):
    for uid, uinfo in data.items():
        if uinfo.get('username', '').lower() == username.lower(): return uid
    return None

def calculate_level(xp): return int((xp / 100) ** 0.5) + 1
def calculate_total_power(user_data): return sum(a.get('power', 0) for a in user_data.get('zoo', []))

# --- ржкрзНрж░ржзрж╛ржи ржХржорж╛ржирзНржб ---
async def start_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user
    data = load_data()
    ensure_user_data(data, user.id, user.username or user.full_name)
    await save_data(data)
    keyboard = [["ЁЯПЮя╕П Hunt", "ЁЯР╛ My Zoo", "ЁЯСд Profile"], ["тЪФя╕П Battle", "ЁЯТ░ Bet", "ЁЯЩП Pray"], ["ЁЯОБ Claim", "ЁЯУЬ Guide", "ЁЯПЖ Leaderboard"]]
    main_keyboard = ReplyKeyboardMarkup(keyboard, resize_keyboard=True)
    start_text = "ЁЯОо <b>Welcome to Battle Nexus</b> ЁЯОо\n\nI am an interactive game bot. Use the menu below to play!"
    await update.message.reply_text(start_text + FOOTER, reply_markup=main_keyboard, parse_mode=ParseMode.HTML)

async def profile_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user; user_id = str(user.id); data = load_data()
    ensure_user_data(data, user_id, user.username or user.full_name)
    user_data = data[user_id]
    level = calculate_level(user_data['xp']); total_power = calculate_total_power(user_data)
    profile_text = (f"ЁЯСд <b>Player Profile: @{user_data.get('username', 'N/A')}</b>\n\n"
                    f"ЁЯПЕ Level: <code>{level}</code> (XP: {user_data['xp']})\n"
                    f"ЁЯТ░ Balance: <code>{user_data.get('balance', 0)}</code> coins\n"
                    f"ЁЯР╛ Animals: <code>{len(user_data['zoo'])}</code>\n"
                    f"ЁЯТе Total Power: <code>{total_power}</code>\n"
                    f"ЁЯНА Luck: <code>{user_data['luck']:.2f}</code>")
    await update.message.reply_text(profile_text, parse_mode=ParseMode.HTML)

async def hunt_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user; user_id = str(user.id); data = load_data()
    ensure_user_data(data, user_id, user.username or user.full_name); user_data = data[user_id]
    if time.time() - user_data.get('last_hunt', 0) < HUNT_COOLDOWN: await update.message.reply_text("тП│ You are tired."); return
    luck_factor = user_data.get('luck', 1.0); qualities = list(ANIMAL_QUALITIES.keys()); weights = [10, 20, 40, 20 * luck_factor, 8 * luck_factor, 2 * luck_factor]
    found_animal_base = random.choice(ANIMALS); found_quality = random.choices(qualities, weights=weights, k=1)[0]
    new_animal = {'uid': str(uuid.uuid4())[:8], 'name': found_animal_base['name'], 'icon': found_animal_base['icon'], 'quality': found_quality, 'xp': 0, 'level': 1, 'power': int(found_animal_base['base_power'] * ANIMAL_QUALITIES[found_quality])}
    user_data['zoo'].append(new_animal); user_data['last_hunt'] = time.time()
    await save_data(data)
    await update.message.reply_text(f"You found a Lvl {new_animal['level']} <b>{new_animal['name']}</b> {new_animal['icon']}!\nQuality: <code>[{new_animal['quality']}]</code> | Power: <code>{new_animal['power']}</code>", parse_mode=ParseMode.HTML)

async def zoo_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user; user_id = str(user.id); data = load_data()
    ensure_user_data(data, user_id, user.username or user.full_name); user_zoo = data[user_id].get('zoo', [])
    message = update.message or update.callback_query.message
    if not user_zoo: await message.reply_text("Your zoo is empty! Use 'Hunt'."); return
    total_power = calculate_total_power(data[user_id])
    text_to_send = f"ЁЯР╛ <b>Your Zoo</b> ЁЯР╛\n<b>Total Power:</b> <code>{total_power}</code>\nUse <code>/sell [ID]</code> to sell.\n\n"
    for animal in sorted(user_zoo, key=lambda x: x['power'], reverse=True):
        text_to_send += f"тАв {animal['icon']} Lvl {animal['level']} <b>{animal['name']}</b> (Pwr: <code>{animal['power']}</code>, ID: <code>{animal['uid']}</code>)\n"
    if update.callback_query: await update.callback_query.edit_message_text(text_to_send, parse_mode=ParseMode.HTML)
    else: await message.reply_text(text_to_send, parse_mode=ParseMode.HTML)

async def claim_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user; user_id = str(user.id); data = load_data()
    ensure_user_data(data, user_id, user.username or user.full_name); user_data = data[user_id]
    if time.time() - user_data.get('last_claim', 0) < CLAIM_COOLDOWN:
        remaining = int(CLAIM_COOLDOWN - (time.time() - user_data.get('last_claim', 0)))
        await update.message.reply_text(f"тП│ Please wait <code>{remaining}</code> more seconds.", parse_mode=ParseMode.HTML); return
    user_data['balance'] += CLAIM_AMOUNT; user_data['last_claim'] = time.time()
    await save_data(data)
    await update.message.reply_text(f"ЁЯОЙ You claimed <code>{CLAIM_AMOUNT}</code> coins!", parse_mode=ParseMode.HTML)

async def leaderboard_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    data = load_data();
    if not data: await update.message.reply_text("No players yet."); return
    sorted_players = sorted(data.items(), key=lambda item: item[1].get('balance', 0), reverse=True)
    leaderboard_text = "ЁЯПЖ <b>Richest Players Leaderboard</b> ЁЯПЖ\n\n"
    for i, (user_id, user_data) in enumerate(sorted_players[:10]):
        leaderboard_text += f"{i + 1}. <b>@{user_data.get('username', 'N/A')}</b> - <code>{user_data.get('balance', 0)}</code> coins\n"
    await update.message.reply_text(leaderboard_text, parse_mode=ParseMode.HTML)

async def pray_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user; user_id = str(user.id); data = load_data()
    ensure_user_data(data, user_id, user.username or user.full_name); user_data = data[user_id]
    if time.time() - user_data.get('last_pray', 0) < PRAY_COOLDOWN:
        await update.message.reply_text("ЁЯЩП You can pray once a minute."); return
    user_data['luck'] += 0.1; user_data['last_pray'] = time.time()
    await save_data(data)
    await update.message.reply_text(f"Your luck increased to <code>{user_data['luck']:.2f}</code>.", parse_mode=ParseMode.HTML)

async def guide_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    keyboard = [
        [
            InlineKeyboardButton("ЁЯЗзЁЯЗй ржмрж╛ржВрж▓рж╛", callback_data='select_lang_bn'),
            InlineKeyboardButton("ЁЯЗмЁЯЗз English", callback_data='select_lang_en'),
            InlineKeyboardButton("ЁЯЗ╕ЁЯЗж ╪з┘Д╪╣╪▒╪и┘К╪й", callback_data='select_lang_ar')
        ]
    ]
    await update.message.reply_text("Please select a language for the guide:", reply_markup=InlineKeyboardMarkup(keyboard))

# --- ржорж╛рж▓рзНржЯрж┐ржкрзНрж▓рзЗржпрж╝рж╛рж░ ржУ ржЧрзЗржорж┐ржВ ржХржорж╛ржирзНржб ---
async def give_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    sender = update.effective_user; args = context.args
    if len(args) != 2: await update.message.reply_text("тЭМ Usage: <code>/give @username [amount]</code>", parse_mode=ParseMode.HTML); return
    recipient_username = args[0].lstrip('@')
    amount_str = args[1] 
    try: amount = int(amount_str); assert amount > 0
    except (ValueError, AssertionError): await update.message.reply_text("тЭМ Invalid amount."); return
    if recipient_username.lower() == (sender.username or "").lower(): await update.message.reply_text("тЭМ Can't give to yourself."); return
    
    data = load_data(); sender_id_str = str(sender.id); ensure_user_data(data, sender.id, sender.username)
    if data[sender_id_str].get('balance', 0) < amount: await update.message.reply_text("тЭМ Not enough balance."); return
    
    recipient_id = find_user_id_by_username(data, recipient_username)
    if not recipient_id: await update.message.reply_text(f"тЭМ Player @{recipient_username} not found. They must /start the bot first."); return
    
    data[sender_id_str]['balance'] -= amount; data[recipient_id]['balance'] += amount
    await save_data(data)
    await update.message.reply_text(f"тЬЕ Sent <code>{amount}</code> coins to @{recipient_username}.", parse_mode=ParseMode.HTML)

async def pvp_battle_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    challenger = update.effective_user
    if len(context.args) != 1: await update.message.reply_text("тЭМ Usage: <code>/battle @username</code>", parse_mode=ParseMode.HTML); return
    opponent_username = context.args[0].lstrip('@')
    if opponent_username.lower() == (challenger.username or "").lower(): await update.message.reply_text("тЭМ Can't battle yourself."); return
    
    data = load_data(); challenger_id_str = str(challenger.id); ensure_user_data(data, challenger.id, challenger.username)
    opponent_id = find_user_id_by_username(data, opponent_username)
    if not opponent_id: await update.message.reply_text(f"тЭМ Player @{opponent_username} not found."); return
    if not data[challenger_id_str].get('zoo'): await update.message.reply_text("тЭМ You have no animals."); return
    if not data[opponent_id].get('zoo'): await update.message.reply_text(f"тЭМ @{opponent_username} has no animals."); return
    
    battle_id = str(uuid.uuid4())[:8]; PENDING_BATTLES[battle_id] = {'challenger_id': challenger.id, 'challenger_name': challenger.username or challenger.first_name, 'opponent_id': int(opponent_id), 'opponent_name': opponent_username}
    keyboard = [[InlineKeyboardButton("тЬЕ Accept", callback_data=f"accept_battle_{battle_id}"), InlineKeyboardButton("тЭМ Decline", callback_data=f"decline_battle_{battle_id}")]]
    await update.message.reply_text(f"тЪФя╕П <b>Battle Challenge!</b> тЪФя╕П\n\n<b>@{challenger.username or challenger.first_name}</b> challenges <b>@{opponent_username}</b>!\n@{opponent_username}, accept?", reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.HTML)

async def pvp_bet_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    challenger = update.effective_user; args = context.args
    if len(args) != 2: await update.message.reply_text("тЭМ Usage: <code>/bet @username [amount]</code>", parse_mode=ParseMode.HTML); return
    opponent_username = args[0].lstrip('@')
    amount_str = args[1]
    try: amount = int(amount_str); assert amount > 0
    except (ValueError, AssertionError): await update.message.reply_text("тЭМ Invalid amount."); return
    if opponent_username.lower() == (challenger.username or "").lower(): await update.message.reply_text("тЭМ Can't bet against yourself."); return
    
    data = load_data(); challenger_id_str = str(challenger.id); ensure_user_data(data, challenger.id, challenger.username)
    if data[challenger_id_str].get('balance', 0) < amount: await update.message.reply_text("тЭМ Not enough coins."); return
    
    opponent_id = find_user_id_by_username(data, opponent_username)
    if not opponent_id: await update.message.reply_text(f"тЭМ Player @{opponent_username} not found."); return
    if data[opponent_id].get('balance', 0) < amount: await update.message.reply_text(f"тЭМ @{opponent_username} doesn't have enough coins."); return
    
    bet_id = str(uuid.uuid4())[:8]; PENDING_BETS[bet_id] = {'challenger_id': challenger.id, 'challenger_name': challenger.username or challenger.first_name, 'opponent_id': int(opponent_id), 'opponent_name': opponent_username, 'amount': amount}
    keyboard = [[InlineKeyboardButton("тЬЕ Accept", callback_data=f"accept_bet_{bet_id}"), InlineKeyboardButton("тЭМ Decline", callback_data=f"decline_bet_{bet_id}")]]
    await update.message.reply_text(f"ЁЯТ░ <b>Coinflip Bet!</b> ЁЯТ░\n\n<b>@{challenger.username or challenger.first_name}</b> challenges <b>@{opponent_username}</b> to a <code>{amount}</code> coin bet!\n@{opponent_username}, accept?", reply_markup=InlineKeyboardMarkup(keyboard), parse_mode=ParseMode.HTML)

async def slots_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user; user_id = str(user.id); args = context.args
    if len(args) != 1: await update.message.reply_text("тЭМ Usage: <code>/slots [amount]</code>", parse_mode=ParseMode.HTML); return
    amount_str = args[0]
    try: amount = int(amount_str); assert amount > 0
    except(ValueError, AssertionError): await update.message.reply_text("тЭМ Invalid amount."); return
    
    data = load_data(); ensure_user_data(data, user_id, user.username); user_data = data[user_id]
    if user_data.get('balance', 0) < amount: await update.message.reply_text("тЭМ Not enough balance."); return
    
    user_data['balance'] -= amount; emojis = ['ЁЯНТ', 'ЁЯНК', 'ЁЯНЛ', 'ЁЯФФ', 'ЁЯТО', 'ЁЯТ░']; results = random.choices(emojis, k=3)
    slot_msg = f"| {' | '.join(results)} |"; winnings = 0
    if results[0] == results[1] == results[2]: winnings = amount * 10; outcome_msg = f"ЁЯОК JACKPOT! You won <code>{winnings}</code> coins!"
    elif results[0] == results[1] or results[1] == results[2]: winnings = amount * 2; outcome_msg = f"ЁЯОЙ Small Win! You won <code>{winnings}</code> coins!"
    else: outcome_msg = "ЁЯТФ You lost!"
    
    if winnings > 0: user_data['balance'] += winnings
    await save_data(data)
    await update.message.reply_text(f"You bet <code>{amount}</code>...\n{slot_msg}\n\n{outcome_msg}", parse_mode=ParseMode.HTML)

async def sell_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user = update.effective_user; user_id = str(user.id)
    if not context.args: await update.message.reply_text("Usage: `/sell [animal_ID]`"); return
    animal_uid = context.args[0]; data = load_data()
    if user_id not in data or 'zoo' not in data[user_id]: await update.message.reply_text("You have no animals."); return
    animal_to_sell = next((a for a in data[user_id]['zoo'] if a['uid'] == animal_uid), None)
    if not animal_to_sell: await update.message.reply_text(f"No animal with ID: `{animal_uid}`"); return
    
    sell_price = animal_to_sell.get('power', 0) // 2
    data[user_id]['zoo'].remove(animal_to_sell); data[user_id]['balance'] += sell_price
    await save_data(data)
    await update.message.reply_text(f"тЬЕ Sold {animal_to_sell['icon']} for `{sell_price}` coins.", parse_mode=ParseMode.HTML)

# --- ржмрж╛ржЯржи ржПржмржВ ржорзЗржирзБ рж╣рзНржпрж╛ржирзНржбрж▓рж╛рж░ ---
async def battle_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    keyboard = [[InlineKeyboardButton("ЁЯдЦ Battle v/s Bot", callback_data='pve_battle_start')], [InlineKeyboardButton("ЁЯСе Battle v/s Player", callback_data='pvp_battle_info')]]
    await update.message.reply_text('Choose your battle type:', reply_markup=InlineKeyboardMarkup(keyboard))

async def bet_menu(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    keyboard = [[InlineKeyboardButton("ЁЯО░ Play Slots (vs Bot)", callback_data='slots_info')], [InlineKeyboardButton("ЁЯкЩ Coinflip (vs Player)", callback_data='pvp_bet_info')]]
    await update.message.reply_text('Choose your bet type:', reply_markup=InlineKeyboardMarkup(keyboard))

async def button_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query; user = query.from_user; await query.answer()
    data_parts = query.data.split('_')
    
    if data_parts[0] == 'select' and data_parts[1] == 'lang':
        lang_code = data_parts[2]
        await query.edit_message_text(GUIDE_TEXTS[lang_code], parse_mode=ParseMode.HTML)
        return

    if query.data == 'pve_battle_start':
        data = load_data(); user_id = str(user.id); ensure_user_data(data, user_id, user.username); user_power = calculate_total_power(data[user_id])
        if user_power == 0: await query.edit_message_text("You have no animals!"); return
        bot_power = int(user_power * random.uniform(0.7, 1.3)); result_text = f"тЪФя╕П <b>Battle vs. Bot</b> тЪФя╕П\n\nYour Power: <code>{user_power}</code>\nBot's Power: <code>{bot_power}</code>\n\n"
        if user_power >= bot_power: data[user_id]['xp'] += PLAYER_XP_FOR_WIN; result_text += "ЁЯОЙ <b>YOU WON!</b>"
        else: data[user_id]['xp'] += PLAYER_XP_FOR_LOSS; result_text += "ЁЯТФ <b>YOU LOST!</b>"
        await save_data(data); await query.edit_message_text(result_text, parse_mode=ParseMode.HTML); return
    
    if query.data == 'pvp_battle_info': await query.message.reply_text("To challenge a player, type:\n<code>/battle @username</code>", parse_mode=ParseMode.HTML); await query.message.delete(); return
    if query.data == 'slots_info': await query.message.reply_text("To play slots, type:\n<code>/slots [amount]</code>", parse_mode=ParseMode.HTML); await query.message.delete(); return
    if query.data == 'pvp_bet_info': await query.message.reply_text("To bet with a player, type:\n<code>/bet @username [amount]</code>", parse_mode=ParseMode.HTML); await query.message.delete(); return

    action = data_parts[0] if data_parts else ""
    if action == "accept" or action == "decline":
        game_type = data_parts[1]; game_id = data_parts[2]; pending_dict = PENDING_BATTLES if game_type == "battle" else PENDING_BETS; game_info = pending_dict.get(game_id)
        if not game_info or user.id != game_info['opponent_id']: await query.answer("This is not for you.", show_alert=True); return
        if action == "decline": del pending_dict[game_id]; await query.edit_message_text(f"<i>{game_type.capitalize()} challenge declined.</i>", parse_mode=ParseMode.HTML); return
        
        data = load_data()
        
        if game_type == "battle":
            cid, oid = str(game_info['challenger_id']), str(game_info['opponent_id']); c_power, o_power = calculate_total_power(data[cid]), calculate_total_power(data[oid])
            res_text = f"тЪФя╕П <b>PvP Battle Result</b> тЪФя╕П\n\n@{game_info['challenger_name']}'s Power: <code>{c_power}</code>\n@{game_info['opponent_name']}'s Power: <code>{o_power}</code>\n\n"
            if c_power >= o_power: winner, winner_data, loser_data = game_info['challenger_name'], data[cid], data[oid]
            else: winner, winner_data, loser_data = game_info['opponent_name'], data[oid], data[cid]
            res_text += f"ЁЯОЙ <b>@{winner} wins!</b>"; winner_data['xp'] += PLAYER_XP_FOR_WIN; loser_data['xp'] += PLAYER_XP_FOR_LOSS
            await query.edit_message_text(res_text, parse_mode=ParseMode.HTML)
        elif game_type == "bet":
            amount = game_info['amount']; cid, oid = str(game_info['challenger_id']), str(game_info['opponent_id'])
            if data[cid]['balance'] < amount or data[oid]['balance'] < amount: await query.edit_message_text("Bet cancelled. A player lacks funds."); return
            data[cid]['balance'] -= amount; data[oid]['balance'] -= amount
            winner_id, winner_name = random.choice([(cid, game_info['challenger_name']), (oid, game_info['opponent_name'])])
            data[winner_id]['balance'] += (amount * 2)
            await query.edit_message_text(f"<b>Bet Finished!</b>\n\nЁЯОЙ <b>@{winner_name}</b> won the coinflip and <code>{amount*2}</code> coins!", parse_mode=ParseMode.HTML)
        
        del pending_dict[game_id]
        await save_data(data)

async def text_handler(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    text = update.message.text
    command_map = {"ЁЯПЮя╕П Hunt": hunt_command, "ЁЯР╛ My Zoo": zoo_command, "ЁЯСд Profile": profile_command, "тЪФя╕П Battle": battle_menu, "ЁЯТ░ Bet": bet_menu, "ЁЯЩП Pray": pray_command, "ЁЯОБ Claim": claim_command, "ЁЯУЬ Guide": guide_command, "ЁЯПЖ Leaderboard": leaderboard_command}
    if text in command_map: await command_map[text](update, context)

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # # ржЪрзВрзЬрж╛ржирзНржд рж╕ржорж╛ржзрж╛ржи: ржмржЯ ржЪрж╛рж▓рж╛ржирзЛрж░ ржХрзЛржб # # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
def main() -> None:
    """ржмржЯ рж╕рзЗржЯржЖржк ржХрж░рзЗ ржПржмржВ ржЪрж╛рж▓рж╛рзЯред"""
    application = Application.builder().token(TELEGRAM_TOKEN).build()
    
    # рж╕ржХрж▓ рж╣рзНржпрж╛ржирзНржбрж▓рж╛рж░ ржпрзЛржЧ ржХрж░рж╛ рж╣ржЪрзНржЫрзЗ
    handlers = [
        CommandHandler("start", start_command), CommandHandler("profile", profile_command), CommandHandler("zoo", zoo_command),
        CommandHandler("hunt", hunt_command), CommandHandler("claim", claim_command), CommandHandler("pray", pray_command),
        CommandHandler("guide", guide_command), CommandHandler("leaderboard", leaderboard_command),
        CommandHandler("give", give_command), CommandHandler("battle", pvp_battle_command),
        CommandHandler("bet", pvp_bet_command), CommandHandler("slots", slots_command), CommandHandler("sell", sell_command),
        CallbackQueryHandler(button_handler), MessageHandler(filters.TEXT & ~filters.COMMAND, text_handler)
    ]
    application.add_handlers(handlers)

    print("Battle Nexus Bot (Final Version) is running...")

    # ржПржЗ ржХржорж╛ржирзНржбржЯрж┐ ржПржХржЯрж┐ ржмрзНрж▓ржХрж┐ржВ ржХрж▓ ржПржмржВ ржПржЯрж┐ ржирж┐ржЬрзЗ ржерзЗржХрзЗржЗ рж╕ржмржХрж┐ржЫрзБ ржорзНржпрж╛ржирзЗржЬ ржХрж░рзЗ ржирзЗржмрзЗ
    application.run_polling()


if __name__ == "__main__":
    main()
